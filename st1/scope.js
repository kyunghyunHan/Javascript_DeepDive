// scope(유효범위)는 자바스크립트를 포함한 모든 프로그래밍 언어의 기본적인 중요한 개념이다.

function add(x,y){
    //매개변수는 함수 몸체 내부에서만 참조할 수 있다.
    //즉 , 매개변수의 스코프는 함수 몸체 내부다.
    console.log(x,y); //2,5
    return x+y;
}
add(2,5);

//매개변수는 함수 몸체 내부에서만 참조할 수 있다.
console.log(x,y); // Error : is not defined

var var1=1; //코드의 가장 바깥 영역에서 선언한 변수

if (true){
    var var2 =2; //코드 블록 내에서 선언한 변수
    if(true) {
        var var3 = 3; //중첩된 코드 블록 내에서 선언한 변수

    }
}
function foo( ){
    var var4=4;//함수 내에서 선언한 변수

    function bar(){
        var var5=5; //중첩된 함수 내에서 선언한 변수
    }
}

console.log(var1); //1
console.log(var2); //2
console.log(var3); //3
console.log(var4); // Error:var4 is not defied
console.log(var5); //Error:var5 is not defied

//모든 식별자(변수이름, 함수이름, 클래스이름등)은 자신이 선언된 위치에 희해 다른 코드가 식별자 자신을 참조할 수 있는 유효범위가 결정된다.
//이를 스코프라 한다.즉 스코프는 식별자가 유효한 범위

var x = 'globla';

function foo(){
    var x = 'local';
    console.log(x); // 1번

    
}
foo();

console.log(x); //2번
//코드의 가장 바깥 영역과 foo 함수 내부에 같은이름을 갖는 x변수를 선언했고, 1번과 2번에서 x변수를 참조한다.이떄 자바스크립트 엔진은 이름이
//같은 두개의 변수중에서 어떤 변수를 참조해야할지 결정한다. 이를 식별자 결정이라 한다. 자바스크립트 엔진은 스코프를 통해 어떤변수를 참조해야할지 결정한다.
//스코프란 자바스크립트 엔진이 식별자를 검색 할 떄 사용하는 규칙
//1번과 2번은 동일한 이름이 스코프지만 다른 뱔개의 변수이다.

// var 키워드로 선언된 변수는 같은 스코프 내에서 중복 선언이 허용된다.이는 의도치 않게 변수 값이 재할당 되어 변경되는 부작용을 일으킨다

function foo(){
    var x = 1;
    //var 키워드로 선언된 변수는 같은 스코프 내에서 중복 선언을 허용한다.
    //아래 변수 선언문은 자바스크립트 엔진에 의해 var 키워드가 없는 것처럼 동작한다.
    var x = 2;
    console.log(x); //2
}
foo();
//하지만 let이나 const키워드로 선언된 변수는 같은 스코프내에서 중복 선언을 하지 않는다.
function bar (){
    let x = 1;
    //let 이나 const키워드로 선언된 변수는 같은 스코프 내에서 중복 선언을 허용하지 않는다.
    let x = 2; //Error

}
bar();

//코드는 global과 local으로 구분될 수 있다

//구분      설명          스코프     변수
//전역  코드의 가장 바깥영역  전역스코프 전역변수
//지역  함수 몸체 내부      지역 스코프 지역변수

var x = "global x";                          //전역스코프
var y = "globla y";                           //전역스코프

function outer(){                              //지역스코프
    var z = "outer's local z";

    console.log(x); //global x
    console.log(y); //global y
    console.log(z); //outer's local z
    
    function inner(){
        var x = "inner's local";                //지역스코프

        console.log(x);  // "inner's local"; 
        console.log(y);  // global y
        console.log(z);  // outer's local z
}

inner();                                        //지역스코프
}
outer();

console.log(x); //global x                //전역스코프
console.log(z);   //Error                   //전역스코프

//전역변수는 어디서든 참조할 수 있다.
//지역이란 함수 몸체 내부를 말한다.
//지역변수는 자신의 지역 스코프와 하위지역 스코프에서 유요하다.
//함수 몸체 내부에서 함수가 정의된 것을 함수의 중첩이라 한다. 함수 몸체 내부에서 정의한 함수를 중첩함수, 중첩함수를 포함한 함수를 외부함수라 한다.
//함수는 중첩될 수 있으므로 함수의 지역 스코프도 중첩될수 있다. 스코프가 함수의 중첩에 의해 계층적 구조를 갖는다.
//모든 지역스코프의 최상위 스코프는 전역스코프 이며 계층적으로 연결된 것을 스코프 체인이라 한다. 
//변수를 참조할 때 자바스크립트는 스코프 체인을 통해 변수를 참조하는 코드의 스코프에서 시작하여 상위 스코프 방향으로 이동하며 선언되 변수를 검색한다.
//상위 스코프에서 유효한 변수는 하위스코프에서 자유롭게 참조가 가능하지만 하위 스코프에서 유효한 변수를 상위 스코프에서 참조할 수 없다.

//전역함수
function foo(){
    console.log('global fuunction foo');
}

function bar (){
    //중첨함수
    function foo(){
        console.log('local function foo');
    }
foo();
}
bar();

//지역은 함수 몸체 내부를 말하고 지역은 지역스코프를 만든다. 이는 코드 블록이 아닌 함수에 의해서만 지역스코프가 생긴다는 의미이다.
//c 나 자바등을 비롯한 대부분의 프로그래밍 언어는 함수 몸체만이 아니라 모든 코드블록이 지역스코프를 만든다.이러한 특성을 블록레벨스코프라한다.
//but var키워드로 선언된 변수는 오로지 함수의 코드블록(몸체)만을 지역스코프라 인정한다.
//이러한 특성을 function level scope 라한다.

var x=1;
if (true){
    //var키워드로 선언된 변수는 함수의 코드블록만을 지역스코프로 인정한다
    //함수 밖에서 var 키워드로 선언된 변수는 코드 블록내에서 선언되었다 할지라도 모두 전역변수이다.
    //따라서 x는 전역변수이다 이미 선언된 전역변수 x가 있으므로 x변수는 중복 선언된다.
    //이는 의도치 않게 변수값이 변경되는 부작용을 발생시킨다.
    var x =10;
}
console.log(x); //10

var i = 10;

//for 문에서 선언한 i는 전역변수이다. 이미 선언된 전역변수 i가 있으므로 중복 선언된다.
for (var i =0; i <5; i++){
    console.log(i); // 0  1 2 3 4

}
//의도치 않게 변수의 값이 변경되었다.
console.log(i); //5
//var 키워드로 선언된 변수는 오로지 함수의 코드블록만을 지역스코프로 인정하지만
// let ,const키워드는 블록레벨 스코프를 지원한다. 

var x = 1;
function foo(){
    var x=10;
    bar();
}
function bar(){
    console.log(x);

}
foo(); //? //1
bar(); //??  //1

//위의 결과는 bar 함수의 상위 스코프가 무엇잇지에 결정된다.
// 1. 함수를 어디서 호출했는지에 따라 함수의 상위 스코프를 결정한다.
// 2. 함수를 어디서 정의했는지에 따라 함수의 상위 스코프를 결정한다.

//첫번쨰 방식을 동적스코프라한다
//두번쨰 방식을 렉시컬 스코프라한다
//자바스크립트는 렉시컬 스코프를 따르므로 함수를 어디서 호출했는지가 아니라 함수를 어디서 정의헀는지에 따라 상위 스코프를 결정한다.
//함수가 호출된 위치는 상위스코프 결정에 어떠한 영향도 주지 않는다.즉 함수의 상위스코프는 언제나 자신이 정의된 스코프이다.
//이처럼 함수의 상위 스코프는 함수 정의가 실행될 떄 정적으로 결정된다.함수 정의가 실행되어 생성된 함수 갹체는 이렇게 결정된 상위 스코프를 기억한다.
//함수가 호출될 때마다 함수의 상위 스코프를 참조할 필요가 있기 떄문이다.